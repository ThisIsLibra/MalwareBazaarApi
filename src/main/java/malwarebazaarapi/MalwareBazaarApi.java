/*
 * Copyright (C) 2021 Max 'Libra' Kersten [@Libranalysis, https://maxkersten.nl]
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package malwarebazaarapi;

import java.io.ByteArrayOutputStream;
import java.util.List;
import malwarebazaarapi.json.JsonParser;
import malwarebazaarapi.model.MalwareBazaarSample;
import malwarebazaarapi.network.MalwareBazaarConnector;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import org.json.JSONObject;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import net.lingala.zip4j.ZipFile;
import net.lingala.zip4j.exception.ZipException;
import net.lingala.zip4j.io.inputstream.ZipInputStream;
import net.lingala.zip4j.model.FileHeader;

/**
 * This class is the only required class to instantiate to connect with Malware
 * Bazaar's API endpoints. Other classes in the relevant packages are used
 * within this class, and will be instantiated if need be.
 *
 * @author Max 'Libra' Kersten [@Libranalysis, https://maxkersten.nl]
 */
public class MalwareBazaarApi {

    /**
     * The connector object to make HTTP(S) connections to the API endpoint with
     */
    private MalwareBazaarConnector connector;

    /**
     * The object to parse returned JSON objects with
     */
    private JsonParser jsonParser;

    /**
     * Creates an API instance with the given key, which can then be used to
     * interact with Malware Bazaar's API endpoints
     *
     * @param key the API key for the service
     */
    public MalwareBazaarApi(String key) {
        this.jsonParser = new JsonParser();
        String apiUrl = "https://mb-api.abuse.ch/api/v1/";
        this.connector = new MalwareBazaarConnector(key, apiUrl);
    }

    /**
     * Checks if the given argument is between 0 and 1000. Malware Bazaar's
     * limit for API requests is 1000 results. Any value higher than that will
     * be capped to 1000. Any negative value will reset the limit to the default
     * of 100.
     *
     * @param limit the limit to check
     * @return the given limit, unless the value is less than zero or more than
     * 1000
     */
    private int checkLimit(int limit) {
        if (limit > 1000) {
            limit = 1000;
        } else if (limit < 0) {
            limit = 100;
        }
        return limit;
    }

    /**
     * Connect to the API endpoint with the given multipart entity builder, and
     * parse the response into a list of Malware Bazaar Sample objects.
     *
     * @param builder the builder to use in the request to the API endpoint
     * @return an array list of Malware Bazaar Sample objects from the API
     * endpoint
     * @throws IOException if the query status in the response indicates the
     * request was not successful
     */
    private List<MalwareBazaarSample> connectAndParse(MultipartEntityBuilder builder) throws IOException {
        String json = new String(connector.post(builder));

        if (jsonParser.checkQueryStatus(json) == false) {
            throw new IOException(new JSONObject(json).optString("query_status"));
        }

        return jsonParser.parseMalwareBazaarSamples(json);
    }

    /**
     * Uploads the given file to Malware Bazaar
     *
     * @param file the file that is to be uploaded
     * @throws IOException if the given file is a directory, does not exist, or
     * if anything goes wrong with the HTTP(S) request
     */
    public void uploadFile(File file) throws IOException {
        if (file.exists() == false) {
            throw new IOException("The given file (\"" + file.getAbsolutePath() + "\") does not exist!");
        }
        if (file.isDirectory() == true) {
            throw new IOException("The given file object (\"" + file.getAbsolutePath() + "\") points to a directory!");
        }

        JSONObject jsonObject = new JSONObject();
        String json = jsonObject.toString();

        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addBinaryBody("file", file);
        builder.addTextBody("json_data", json);

        String response = new String(connector.post(builder));
        String queryStatus = new JSONObject(response).optString("query_status");

        if (jsonParser.checkQueryStatus(response) == false) {
            throw new IOException("The server status is \"" + queryStatus + "\"");
        }
    }

    /**
     * Downloads the ZIP archive which contains the sample. The archive's
     * password is <em>infected</em>.
     *
     * @param sha256 the SHA-256 hash of the sample that is to be downloaded
     * @return the ZIP archive as a byte array
     * @throws IOException if anything goes wrong with the HTTP(S) request
     */
    public byte[] downloadZip(String sha256) throws IOException {
        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_file");
        builder.addTextBody("sha256_hash", sha256);

        return connector.post(builder);
    }

    /**
     * Downloads the given sample from Malware Bazaar, based on the given
     * SHA-256 hash. To download a sample in a ZIP archive with
     * <em>infected</em> as the password, please refer to downloadZip. This
     * function extracts the ZIP archive to a temporary location, where the
     * first file is then read into memory, and subsequently returned. The
     * temporary file is deleted prior to returning this function.
     *
     * @param sha256 the SHA-256 hash of the sample to download
     * @return the raw sample
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * with the archive extraction or deletion
     */
    public byte[] download(String sha256) throws IOException {
        String tempPath = System.getProperty("java.io.tmpdir") + System.getProperty("file.separator") + sha256;
        return download(sha256, tempPath);
    }

    /**
     * Downloads the given sample from Malware Bazaar, based on the given
     * SHA-256 hash.To download a sample in a ZIP archive with
     * <em>infected</em> as the password, please refer to downloadZip. This
     * function extracts the ZIP archive to the given location, where the first
     * file is then read into memory, and subsequently returned. The temporary
     * file is deleted prior to returning this function.
     *
     * @param sha256 the SHA-256 hash of the sample to download
     * @param tempPath the temporary path to extract the ZIP archive to
     * @return the raw sample
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * with the archive extraction or deletion
     */
    public byte[] download(String sha256, String tempPath) throws IOException {
        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_file");
        builder.addTextBody("sha256_hash", sha256);

        byte[] zip = connector.post(builder);

        File localFile = new File(tempPath);
        localFile.getParentFile().mkdirs();
        Files.write(localFile.toPath(), zip); //overwrites if it exists, not thread safe when downloading the same data, unless a unique path is given

        String password = "infected";

        try {
            ZipFile zipFile = new ZipFile(localFile);
            if (zipFile.isEncrypted()) {
                zipFile.setPassword(password.toCharArray());
            }

            List<FileHeader> headers = zipFile.getFileHeaders();
            ZipInputStream inputStream = zipFile.getInputStream(headers.get(0));
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

            int offset = -1;
            byte[] buff = new byte[1024];
            while ((offset = inputStream.read(buff)) != -1) {
                outputStream.write(buff, 0, offset);
            }
            localFile.delete();
            return outputStream.toByteArray();
        } catch (ZipException e) {
            localFile.delete();
            throw new IOException("Error whilst handling the (now deleted) ZIP archive:\n" + e.getMessage());
        }
    }

    /**
     * Checks if the given sample is present on Malware Bazaar
     *
     * @param sha256 the SHA-256 hash of the sample to check for
     * @return the sample object
     * @throws IOException if anything goes wrong with the HTTP requests, or if
     * the sample does not exist on Malware Bazaar
     */
    public MalwareBazaarSample querySample(String sha256) throws IOException {
        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_info");
        builder.addTextBody("hash", sha256);

        List<MalwareBazaarSample> samples = connectAndParse(builder);
        if (samples.size() > 0) {
            return samples.get(0);
        } else {
            //Redundant due to the connectAndParse check, but kept in place as an additional safeguard
            throw new IOException("No result found for \"" + sha256 + "\"");
        }
    }

    /**
     * Gets all hits for a given tag, with a maximum of 1000. Any value that is
     * below 0 will result in the default value of 100. Any value above 1000 is
     * capped to 1000.
     *
     * @param tag the tag to look for
     * @param limit the maximum amount of results that are to be returned,
     * ranging between 0 and 1000
     * @return a list of matching Malware Bazaar Sample objects
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the tag is invalid or unknown
     */
    public List<MalwareBazaarSample> queryTag(String tag, int limit) throws IOException {
        limit = checkLimit(limit);

        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_taginfo");
        builder.addTextBody("tag", tag);
        builder.addTextBody("limit", "" + limit);

        return connectAndParse(builder);
    }

    /**
     * Gets all hits for a given signature, with a maximum of 1000. Any value
     * that is below 0 will result in the default value of 100. Any value above
     * 1000 is capped to 1000.
     *
     * @param signature the signature to look for
     * @param limit the maximum amount of results that are to be returned,
     * ranging between 0 and 1000
     * @return a list of matching Malware Bazaar Sample objects
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the signature is invalid or unknown
     */
    public List<MalwareBazaarSample> querySignature(String signature, int limit) throws IOException {
        limit = checkLimit(limit);

        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_siginfo");
        builder.addTextBody("signature", signature);
        builder.addTextBody("limit", "" + limit);

        return connectAndParse(builder);
    }

    /**
     * Gets all hits for a given file type, with a maximum of 1000. Any value
     * that is below 0 will result in the default value of 100. Any value above
     * 1000 is capped to 1000.
     *
     * @param fileType the file type to look for
     * @param limit the maximum amount of results that are to be returned,
     * ranging between 0 and 1000
     * @return a list of matching Malware Bazaar Sample objects
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the file type is invalid or unknown
     */
    public List<MalwareBazaarSample> queryFileType(String fileType, int limit) throws IOException {
        limit = checkLimit(limit);

        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_file_type");
        builder.addTextBody("file_type", fileType);
        builder.addTextBody("limit", "" + limit);

        return connectAndParse(builder);
    }

    /**
     * Gets all hits for a given ClamAV signature name, with a maximum of 1000.
     * Any value that is below 0 will result in the default value of 100. Any
     * value above 1000 is capped to 1000.
     *
     * @param clamAvSignature the ClamAV signature name to look for
     * @param limit the maximum amount of results that are to be returned,
     * ranging between 0 and 1000
     * @return a list of matching Malware Bazaar Sample objects
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the ClamAV signature name is invalid or unknown
     */
    public List<MalwareBazaarSample> queryClamAvSignature(String clamAvSignature, int limit) throws IOException {
        limit = checkLimit(limit);

        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_clamavinfo");
        builder.addTextBody("clamav", clamAvSignature);
        builder.addTextBody("limit", "" + limit);

        return connectAndParse(builder);
    }

    /**
     * Gets all hits for a given import hash, with a maximum of 1000. Any value
     * that is below 0 will result in the default value of 100. Any value above
     * 1000 is capped to 1000.
     *
     * @param importHash the import hash to look for
     * @param limit the maximum amount of results that are to be returned,
     * ranging between 0 and 1000
     * @return a list of matching Malware Bazaar Sample objects
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the import hash is invalid or unknown
     */
    public List<MalwareBazaarSample> queryImportHash(String importHash, int limit) throws IOException {
        limit = checkLimit(limit);

        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_imphash");
        builder.addTextBody("imphash", importHash);
        builder.addTextBody("limit", "" + limit);

        return connectAndParse(builder);
    }

    /**
     * Gets all hits for a given tlsh hash, with a maximum of 1000. Any value
     * that is below 0 will result in the default value of 100. Any value above
     * 1000 is capped to 1000.
     *
     * @param tlshHash the tlsh hash to look for
     * @param limit the maximum amount of results that are to be returned,
     * ranging between 0 and 1000
     * @return a list of matching Malware Bazaar Sample objects
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the tlsh hash is invalid or unknown
     */
    public List<MalwareBazaarSample> queryTlshHash(String tlshHash, int limit) throws IOException {
        limit = checkLimit(limit);

        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_tlsh");
        builder.addTextBody("tlsh", tlshHash);
        builder.addTextBody("limit", "" + limit);

        return connectAndParse(builder);
    }

    /**
     * Gets all hits for a given telf hash, with a maximum of 1000. Any value
     * that is below 0 will result in the default value of 100. Any value above
     * 1000 is capped to 1000.
     *
     * @param telfHash the telf hash to look for
     * @param limit the maximum amount of results that are to be returned,
     * ranging between 0 and 1000
     * @return a list of matching Malware Bazaar Sample objects
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the telf hash is invalid or unknown
     */
    public List<MalwareBazaarSample> queryTelfHash(String telfHash, int limit) throws IOException {
        limit = checkLimit(limit);

        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_telfhash");
        builder.addTextBody("telfhash", telfHash);
        builder.addTextBody("limit", "" + limit);

        return connectAndParse(builder);
    }
    
    /**
     * Gets all hits for a given golang import hash, with a maximum of 1000. Any value
     * that is below 0 will result in the default value of 100. Any value above
     * 1000 is capped to 1000.
     *
     * @param gimpHash the golang import hash to look for
     * @param limit the maximum amount of results that are to be returned,
     * ranging between 0 and 1000
     * @return a list of matching Malware Bazaar Sample objects
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the golang import hash is invalid or unknown
     */
    public List<MalwareBazaarSample> queryGimpHash(String gimpHash, int limit) throws IOException {
        limit = checkLimit(limit);

        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_gimphash");
        builder.addTextBody("gimphash", gimpHash);
        builder.addTextBody("limit", "" + limit);

        return connectAndParse(builder);
    }

    /**
     * Gets all hits for a given icon dhash, with a maximum of 1000. Any value
     * that is below 0 will result in the default value of 100. Any value above
     * 1000 is capped to 1000.
     *
     * @param iconDhash the icon dhash to look for
     * @param limit the maximum amount of results that are to be returned,
     * ranging between 0 and 1000
     * @return a list of matching Malware Bazaar Sample objects
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the icon dhash is invalid or unknown
     */
    public List<MalwareBazaarSample> queryIconDhash(String iconDhash, int limit) throws IOException {
        limit = checkLimit(limit);

        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_dhash_icon");
        builder.addTextBody("dhash_icon", iconDhash);
        builder.addTextBody("limit", "" + limit);

        return connectAndParse(builder);
    }

    /**
     * Gets all hits for a given Yara rule name, with a maximum of 1000. Any
     * value that is below 0 will result in the default value of 100. Any value
     * above 1000 is capped to 1000.
     *
     * @param yaraRuleName the name of the Yara rule (rule_name) on Malware
     * Bazaar
     * @param limit the maximum amount of results that are to be returned,
     * ranging between 0 and 1000
     * @return a list of matching Malware Bazaar Sample objects
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the name is invalid or unknown
     */
    public List<MalwareBazaarSample> queryYaraRule(String yaraRuleName, int limit) throws IOException {
        limit = checkLimit(limit);

        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_yarainfo");
        builder.addTextBody("yara_rule", yaraRuleName);
        builder.addTextBody("limit", "" + limit);

        return connectAndParse(builder);
    }

    /**
     * Gets a list of samples that are using a code sign certificate issued by
     * the given Certificate Authority (Issuer CN). The maximum amount of
     * samples that this endpoint returns for a given name, is 100.
     *
     * @param issuerCommonName the name to search for
     * @return the results that have been found
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the name is invalid or unknown
     */
    public List<MalwareBazaarSample> queryCodeSigningCertificateByIssuer(String issuerCommonName) throws IOException {
        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_issuerinfo");
        builder.addTextBody("issuer_cn", issuerCommonName);

        return connectAndParse(builder);
    }

    /**
     * Gets a list of samples that are signed with a code sign certificate that
     * matches the given certain Subject Common Name (CN). The maximum amount of
     * samples that this endpoint returns for a given name, is 100.
     *
     * @param subjectCommonName the name to search for
     * @return the results that have been found
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the name is invalid or unknown
     */
    public List<MalwareBazaarSample> queryCodeSigningCertificateBySubject(String subjectCommonName) throws IOException {
        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_subjectinfo");
        builder.addTextBody("subject_cn", subjectCommonName);

        return connectAndParse(builder);
    }

    /**
     * Adds a public comment to the given sample
     *
     * @param sha256 the sample to add the comment to
     * @param comment the comment to add
     * @throws IOException if anything goes wrong with the HTTP(S) request, or
     * if the sample is not present on Malware Bazaar
     */
    public void addComment(String sha256, String comment) throws IOException {
        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "add_comment");
        builder.addTextBody("sha256_hash", sha256);
        builder.addTextBody("comment", comment);

        String json = new String(connector.post(builder));
        if (jsonParser.checkQueryStatus(json) == false) {
            throw new IOException("The server status is \"" + new JSONObject(json).optString("query_status") + "\"");
        }
    }

    /**
     * Gets the information of all samples that were uploaded in the last 60
     * minutes
     *
     * @return a list of all samples that were uploaded in the last 60 minutes
     * @throws IOException if the HTTP request fails
     */
    public List<MalwareBazaarSample> getRecentSamples() throws IOException {
        //String body = "query=get_recent&selector=time";
        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_recent");
        builder.addTextBody("selector", "time");

        return connectAndParse(builder);
    }

    /**
     * Gets the information of the most recent 100 samples on Malware Bazaar
     *
     * @return the most recently uploaded 100 samples on Malware Bazaar
     * @throws IOException if the HTTP request fails
     */
    public List<MalwareBazaarSample> getMostRecentHundredSamples() throws IOException {
        MultipartEntityBuilder builder = MultipartEntityBuilder.create();
        builder.addTextBody("query", "get_recent");
        builder.addTextBody("selector", "100");

        return connectAndParse(builder);
    }

    /**
     * Queries Abuse's datalake for the a ZIP archive of the samples for the
     * given date. The date string needs to be in the following format:
     * <em>YYYY-mm-dd</em> (i.e. 2021-10-31). The time zone that Malware Bazaar
     * uses is UTC. The ZIP archive's password is
     * <em>infected</em>.
     *
     * @param date the day to fetch the sample archive for
     * @return the raw ZIP archive as a zip array
     * @throws IOException if there is a network error, or if the HTTP status
     * code indicates that there was an error
     */
    public byte[] getDailySamples(String date) throws IOException {
        String url = "https://datalake.abuse.ch/malware-bazaar/daily/" + date + ".zip";
        byte[] response = connector.get(url);
        return response;
    }

    /**
     * Queries Abuse's datalake for the a ZIP archive of the samples for the
     * given date. The date string needs to be in the following format:
     * <em>YYYY-mm-dd-HH</em> (i.e. 2021-10-31-18). The time zone that Malware
     * Bazaar uses is UTC. The ZIP archive's password is <em>infected</em>.
     *
     * @param dateTime the day to fetch the sample archive for
     * @return the raw ZIP archive as a zip array
     * @throws IOException if there is a network error, or if the HTTP status
     * code indicates that there was an error
     */
    public byte[] getHourlySamples(String dateTime) throws IOException {
        String url = "https://datalake.abuse.ch/malware-bazaar/hourly/" + dateTime + ".zip";
        byte[] response = connector.get(url);
        return response;
    }
}
